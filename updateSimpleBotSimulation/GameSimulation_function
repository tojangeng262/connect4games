# Game Simulation Functions
def run_game(bot1_class, bot2_class, bot1_name, bot2_name, game_number, ordering):
    game = Connect4Game()
    if ordering == "normal":
        player1 = bot1_class(player_id=1)
        player2 = bot2_class(player_id=2)
        bot1_id = bot1_name
        bot2_id = bot2_name
    else:
        player1 = bot2_class(player_id=1)
        player2 = bot1_class(player_id=2)
        bot1_id = bot2_name
        bot2_id = bot1_name
    while not game.game_over:
        if game.current_player == 1:
            chosen_move = player1.choose_move(game)
        else:
            chosen_move = player2.choose_move(game)
        valid = game.make_move(chosen_move)
        if not valid:
            valid_moves = [col for col in range(game.columns) if game.board[0, col] == 0]
            if valid_moves:
                game.make_move(valid_moves[0])
            else:
                break
        if len(game.move_log) >= game.rows * game.columns:
            break
    if game.move_log:
        winning_player = game.move_log[-1]["player"]
        if ordering == "normal":
            winner_bot = bot1_id if winning_player == 1 else bot2_id
        else:
            winner_bot = bot1_id if winning_player == 1 else bot2_id
    else:
        winner_bot = "Draw"
    game_record = {
        "metadata": {
            "bot1": bot1_id,
            "bot2": bot2_id,
            "game_number": game_number,
            "ordering": ordering,
            "result": winner_bot
        },
        "move_log": game.move_log
    }
    return game_record

def simulate_pairing(bot1_name, bot2_name, bot1_class, bot2_class, simulation_dir):
    total_games = 0
    for game_index in range(1, 501):
        record = run_game(bot1_class, bot2_class, bot1_name, bot2_name, game_number=game_index, ordering="normal")
        filename = os.path.join(simulation_dir, f"{bot1_name}_vs_{bot2_name}_normal_game{game_index}.json")
        with open(filename, "w") as f:
            json.dump(record, f, indent=4)
        total_games += 1
    for game_index in range(501, 1001):
        record = run_game(bot1_class, bot2_class, bot1_name, bot2_name, game_number=game_index, ordering="reversed")
        filename = os.path.join(simulation_dir, f"{bot1_name}_vs_{bot2_name}_reversed_game{game_index}.json")
        with open(filename, "w") as f:
            json.dump(record, f, indent=4)
        total_games += 1
    return total_games

def run_simulation():
    simulation_dir = f"simulation_game_logs_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
    os.makedirs(simulation_dir, exist_ok=True)
    bot_classes = {
        "RandomBot": RandomBot,
        "HeuristicBot": HeuristicBot,
        "MinimaxBot": MinimaxBot,
        "MCTSBot": MCTSBot
    }
    bot_names = list(bot_classes.keys())
    total_games = 0
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = []
        for i in range(len(bot_names)):
            for j in range(i + 1, len(bot_names)):
                bot1_name = bot_names[i]
                bot2_name = bot_names[j]
                bot1_class = bot_classes[bot1_name]
                bot2_class = bot_classes[bot2_name]
                future = executor.submit(simulate_pairing, bot1_name, bot2_name, bot1_class, bot2_class, simulation_dir)
                futures.append(future)
        for future in concurrent.futures.as_completed(futures):
            try:
                total_games += future.result()
            except Exception as e:
                print(f"A task generated an exception: {e}")
    print(f"Simulation completed. Total games played: {total_games}")
